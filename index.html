<!DOCTYPE html>
<html lang="en">

<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>React Chat Platform</title>
    <link href="https://cdn.jsdelivr.net/npm/bootstrap@5.3.0/dist/css/bootstrap.min.css" rel="stylesheet">
    <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.0/css/all.min.css">
    <script src="https://unpkg.com/react@18/umd/react.development.js"></script>
    <script src="https://unpkg.com/react-dom@18/umd/react-dom.development.js"></script>
    <script src="https://unpkg.com/@babel/standalone/babel.min.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/@microsoft/signalr@7.0.0/dist/browser/signalr.min.js"></script>
    <style>
        :root {
            --primary-color: #0088cc;
            --secondary-color: #f8f9fa;
            --text-color: #333;
            --light-gray: #e9ebeb;
            --medium-gray: #d1d7db;
            --dark-gray: #667781;
            --online-status: #00c853;
            --offline-status: #9e9e9e;
            --sent-message: #d9fdd3;
            --received-message: #ffffff;
            --chat-bg: #efeae2;
        }

        * {
            box-sizing: border-box;
        }

        body {
            font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
            background-color: #f0f2f5;
            margin: 0;
            padding: 0;
            overflow: hidden;
        }

        .chat-app {
            height: 100vh;
            display: flex;
            flex-direction: column;
        }

        .chat-container {
            flex: 1;
            background-color: white;
            box-shadow: 0 1px 3px rgba(0, 0, 0, 0.12);
            display: flex;
            min-height: 0;
        }

        .sidebar {
            width: 100%;
            max-width: 350px;
            min-width: 280px;
            background-color: var(--secondary-color);
            border-right: 1px solid var(--medium-gray);
            display: flex;
            flex-direction: column;
        }

        .chat-area {
            flex: 1;
            display: flex;
            flex-direction: column;
            min-width: 0;
        }

        .chat-header {
            background-color: var(--light-gray);
            padding: 15px;
            border-bottom: 1px solid var(--medium-gray);
            min-height: 70px;
            display: flex;
            align-items: center;
        }

        .sidebar-header {
            padding: 15px;
            border-bottom: 1px solid var(--medium-gray);
            background-color: var(--light-gray);
        }

        .search-container {
            padding: 10px;
            position: relative;
        }

        .search-results {
            position: absolute;
            top: 100%;
            left: 10px;
            right: 10px;
            background: white;
            border-radius: 0 0 5px 5px;
            box-shadow: 0 4px 8px rgba(0, 0, 0, 0.1);
            z-index: 100;
            max-height: 300px;
            overflow-y: auto;
        }

        .search-item,
        .chat-item {
            padding: 12px 15px;
            cursor: pointer;
            border-bottom: 1px solid var(--light-gray);
            transition: background-color 0.2s;
        }

        .search-item:hover,
        .chat-item:hover {
            background-color: var(--light-gray);
        }

        .chat-item.active {
            background-color: var(--medium-gray);
        }

        .chats-list {
            flex: 1;
            overflow-y: auto;
        }

        .chat-messages {
            flex: 1;
            overflow-y: auto;
            padding: 15px;
            background: var(--chat-bg);
            background-image: url("data:image/svg+xml,%3Csvg width='100' height='100' viewBox='0 0 100 100' xmlns='http://www.w3.org/2000/svg'%3E%3Cpath d='M11 18c3.866 0 7-3.134 7-7s-3.134-7-7-7-7 3.134-7 7 3.134 7 7 7zm48 25c3.866 0 7-3.134 7-7s-3.134-7-7-7-7 3.134-7 7 3.134 7 7 7zm-43-7c1.657 0 3-1.343 3-3s-1.343-3-3-3-3 1.343-3 3 1.343 3 3 3zm63 31c1.657 0 3-1.343 3-3s-1.343-3-3-3-3 1.343-3 3 1.343 3 3 3zM34 90c1.657 0 3-1.343 3-3s-1.343-3-3-3-3 1.343-3 3 1.343 3 3 3zm56-76c1.657 0 3-1.343 3-3s-1.343-3-3-3-3 1.343-3 3 1.343 3 3 3zM12 86c2.21 0 4-1.79 4-4s-1.79-4-4-4-4 1.79-4 4 1.79 4 4 4zm28-65c2.21 0 4-1.79 4-4s-1.79-4-4-4-4 1.79-4 4 1.79 4 4 4zm23-11c2.76 0 5-2.24 5-5s-2.24-5-5-5-5 2.24-5 5 2.24 5 5 5zm-6 60c2.21 0 4-1.79 4-4s-1.79-4-4-4-4 1.79-4 4 1.79 4 4 4zm29 22c2.76 0 5-2.24 5-5s-2.24-5-5-5-5 2.24-5 5 2.24 5 5 5zM32 63c2.76 0 5-2.24 5-5s-2.24-5-5-5-5 2.24-5 5 2.24 5 5 5zm57-13c2.76 0 5-2.24 5-5s-2.24-5-5-5-5 2.24-5 5 2.24 5 5 5zm-9-21c1.105 0 2-.895 2-2s-.895-2-2-2-2 .895-2 2 .895 2 2 2zM60 91c1.105 0 2-.895 2-2s-.895-2-2-2-2 .895-2 2 .895 2 2 2zM35 41c1.105 0 2-.895 2-2s-.895-2-2-2-2 .895-2 2 .895 2 2 2zM12 60c1.105 0 2-.895 2-2s-.895-2-2-2-2 .895-2 2 .895 2 2 2z' fill='%239C92AC' fill-opacity='0.05' fill-rule='evenodd'/%3E%3C/svg%3E");
        }

        .message-input-container {
            background-color: var(--light-gray);
            padding: 15px;
            border-top: 1px solid var(--medium-gray);
        }

        .message {
            max-width: 75%;
            margin-bottom: 15px;
            clear: both;
            display: flex;
            flex-direction: column;
        }

        .message.sent {
            align-items: flex-end;
            margin-left: auto;
        }

        .message.received {
            align-items: flex-start;
            margin-right: auto;
        }

        .message-content {
            padding: 8px 12px;
            border-radius: 7.5px;
            position: relative;
            word-wrap: break-word;
            max-width: 100%;
        }

        .sent .message-content {
            background-color: var(--sent-message);
            border-top-right-radius: 0;
        }

        .received .message-content {
            background-color: var(--received-message);
            border-top-left-radius: 0;
        }

        .message-time {
            font-size: 0.7rem;
            color: var(--dark-gray);
            margin-top: 3px;
            padding: 0 5px;
        }

        .status-indicator {
            width: 10px;
            height: 10px;
            border-radius: 50%;
            display: inline-block;
            margin-right: 8px;
        }

        .online {
            background-color: var(--online-status);
        }

        .offline {
            background-color: var(--offline-status);
        }

        .typing-indicator {
            padding: 5px 15px;
            font-style: italic;
            color: var(--dark-gray);
            font-size: 0.9rem;
        }

        .unread-count {
            background-color: var(--primary-color);
            color: white;
            border-radius: 50%;
            min-width: 20px;
            height: 20px;
            display: flex;
            align-items: center;
            justify-content: center;
            font-size: 0.75rem;
        }

        .login-container {
            max-width: 400px;
            margin: 100px auto;
            padding: 20px;
            background-color: white;
            border-radius: 10px;
            box-shadow: 0 0 20px rgba(0, 0, 0, 0.1);
        }

        .chat-placeholder {
            display: flex;
            align-items: center;
            justify-content: center;
            height: 100%;
            color: var(--dark-gray);
            text-align: center;
            flex-direction: column;
        }

        .modal-overlay {
            position: fixed;
            top: 0;
            left: 0;
            right: 0;
            bottom: 0;
            background-color: rgba(0, 0, 0, 0.5);
            display: flex;
            align-items: center;
            justify-content: center;
            z-index: 1000;
        }

        .modal-content {
            background-color: white;
            padding: 20px;
            border-radius: 8px;
            width: 90%;
            max-width: 400px;
            max-height: 80vh;
            overflow-y: auto;
        }

        .group-member-list {
            max-height: 200px;
            overflow-y: auto;
            border: 1px solid #ddd;
            border-radius: 4px;
            padding: 10px;
            margin-top: 10px;
        }

        .group-member-item {
            display: flex;
            align-items: center;
            padding: 5px 0;
        }

        /* Responsive Design */
        @media (max-width: 768px) {
            .sidebar {
                position: absolute;
                left: 0;
                top: 0;
                bottom: 0;
                z-index: 10;
                transform: translateX(-100%);
                transition: transform 0.3s ease;
            }

            .sidebar.open {
                transform: translateX(0);
            }

            .chat-area {
                width: 100%;
            }

            .mobile-header {
                display: flex;
                align-items: center;
                padding: 10px;
                background-color: var(--primary-color);
                color: white;
            }

            .menu-toggle {
                background: none;
                border: none;
                color: white;
                font-size: 1.2rem;
                margin-right: 15px;
                cursor: pointer;
            }
        }

        @media (min-width: 769px) {
            .mobile-header {
                display: none;
            }
        }
    </style>
</head>

<body>
    <div id="root"></div>

    <script type="text/babel">
        const { useState, useEffect, useRef, useCallback } = React;

        // Constants
        const APIURL = 'https://localhost:7021';

        // Utility functions
        const formatTime = (dateTime) => {
            const date = new Date(dateTime);
            return date.toLocaleTimeString([], { hour: '2-digit', minute: '2-digit' });
        };

        // Custom hooks
        const useSignalR = (token, currentUser) => {
            const [connection, setConnection] = useState(null);
            const [isConnected, setIsConnected] = useState(false);

            useEffect(() => {
                if (!token || !currentUser) return;

                const newConnection = new signalR.HubConnectionBuilder()
                    .withUrl(`${APIURL}/chatHub`, {
                        accessTokenFactory: () => token
                    })
                    .withAutomaticReconnect()
                    .build();

                newConnection.start()
                    .then(() => {
                        console.log("SignalR Connected");
                        setIsConnected(true);
                    })
                    .catch(err => {
                        console.error('SignalR Connection Error: ', err);
                        setIsConnected(false);
                    });

                setConnection(newConnection);

                return () => {
                    if (newConnection) {
                        newConnection.stop();
                    }
                };
            }, [token, currentUser]);

            return { connection, isConnected };
        };

        // Components
        const StatusIndicator = ({ isOnline }) => (
            <span className={`status-indicator ${isOnline ? 'online' : 'offline'}`}></span>
        );

        const LoginForm = ({ onLogin }) => {
            const [formData, setFormData] = useState({
                email: '',
                password: '',
                firstName: '',
                lastName: ''
            });
            const [isRegistering, setIsRegistering] = useState(false);
            const [isLoading, setIsLoading] = useState(false);

            const handleSubmit = async (e) => {
                e.preventDefault();
                setIsLoading(true);

                try {
                    const endpoint = isRegistering ? '/api/auth/register' : '/api/auth/login';
                    const response = await fetch(`${APIURL}${endpoint}`, {
                        method: 'POST',
                        headers: { 'Content-Type': 'application/json' },
                        body: JSON.stringify(formData)
                    });

                    const data = await response.json();
                    if (data.token) {
                        localStorage.setItem('token', data.token);
                        onLogin(data.user, data.token);
                    } else {
                        alert(`${isRegistering ? 'Registration' : 'Login'} failed: ${data.message || 'Unknown error'}`);
                    }
                } catch (error) {
                    console.error('Auth error:', error);
                    alert(`${isRegistering ? 'Registration' : 'Login'} failed. Please try again.`);
                } finally {
                    setIsLoading(false);
                }
            };

            const handleChange = (e) => {
                setFormData(prev => ({
                    ...prev,
                    [e.target.name]: e.target.value
                }));
            };

            return (
                <div className="login-container">
                    <h2 className="text-center mb-4">Telegram Chat</h2>
                    <form onSubmit={handleSubmit}>
                        <div className="mb-3">
                            <label htmlFor="email" className="form-label">Email</label>
                            <input
                                type="email"
                                className="form-control"
                                name="email"
                                value={formData.email}
                                onChange={handleChange}
                                required
                            />
                        </div>
                        <div className="mb-3">
                            <label htmlFor="password" className="form-label">Password</label>
                            <input
                                type="password"
                                className="form-control"
                                name="password"
                                value={formData.password}
                                onChange={handleChange}
                                required
                            />
                        </div>

                        {isRegistering && (
                            <>
                                <div className="mb-3">
                                    <label htmlFor="firstName" className="form-label">First Name</label>
                                    <input
                                        type="text"
                                        className="form-control"
                                        name="firstName"
                                        value={formData.firstName}
                                        onChange={handleChange}
                                        required
                                    />
                                </div>
                                <div className="mb-3">
                                    <label htmlFor="lastName" className="form-label">Last Name</label>
                                    <input
                                        type="text"
                                        className="form-control"
                                        name="lastName"
                                        value={formData.lastName}
                                        onChange={handleChange}
                                        required
                                    />
                                </div>
                            </>
                        )}

                        <button type="submit" className="btn btn-primary w-100 mb-3" disabled={isLoading}>
                            {isLoading ? 'Loading...' : (isRegistering ? 'Register' : 'Login')}
                        </button>
                    </form>

                    <p className="text-center">
                        {isRegistering ? 'Already have an account?' : "Don't have an account?"}{' '}
                        <button
                            type="button"
                            className="btn btn-link p-0"
                            onClick={() => setIsRegistering(!isRegistering)}
                        >
                            {isRegistering ? 'Login' : 'Register'}
                        </button>
                    </p>
                </div>
            );
        };

        const SearchResults = ({ results, onUserSelect, isVisible }) => {
            if (!isVisible) return null;

            return (
                <div className="search-results">
                    {results.length === 0 ? (
                        <div className="search-item">No users found</div>
                    ) : (
                        results.map(user => (
                            <div
                                key={user.id}
                                className="search-item"
                                onClick={() => onUserSelect(user)}
                            >
                                <div className="d-flex align-items-center">
                                    <StatusIndicator isOnline={user.isOnline} />
                                    <div className="ms-2">
                                        <strong>{user.firstName} {user.lastName}</strong>
                                        <div className="text-muted small">{user.email}</div>
                                    </div>
                                </div>
                            </div>
                        ))
                    )}
                </div>
            );
        };

        const ChatItem = ({ chat, type, isActive, unreadCount, onClick, currentUser }) => (
            <div
                className={`chat-item ${isActive ? 'active' : ''}`}
                onClick={onClick}
            >
                <div className="d-flex align-items-center">
                    {type === 'private' ? (
                        <>
                            <StatusIndicator isOnline={chat.isOnline} />
                            <div className="ms-2 flex-grow-1">
                                <strong>{chat.firstName} {chat.lastName}</strong>
                                <div className="text-muted small">
                                    {chat.isOnline ? 'Online' : `Last seen ${formatTime(chat.lastSeen)}`}
                                </div>
                            </div>
                        </>
                    ) : (
                        <>
                            <i className="fas fa-users me-2"></i>
                            <div className="flex-grow-1">
                                <strong>{chat.name}</strong>
                                <div className="text-muted small">{chat.members?.length || 0} members</div>
                            </div>
                        </>
                    )}
                    {unreadCount > 0 && (
                        <span className="unread-count ms-2">{unreadCount}</span>
                    )}
                </div>
            </div>
        );

        const Message = ({ message, currentUser }) => {
            const isOwn = message.senderId === currentUser.id;

            return (
                <div className={`message ${isOwn ? 'sent' : 'received'}`}>
                    <div className="message-content">
                        {message.type === 'Text' ? (
                            message.content
                        ) : (
                            <div>
                                <i className="fas fa-file"></i> {message.content}
                                {message.attachmentUrl && (
                                    <a href={message.attachmentUrl} target="_blank" rel="noopener noreferrer">
                                        Download
                                    </a>
                                )}
                            </div>
                        )}
                    </div>
                    <div className="message-time">
                        {formatTime(message.sentAt)}
                    </div>
                </div>
            );
        };

        const CreateGroupModal = ({ isOpen, onClose, onCreateGroup, users }) => {
            const [formData, setFormData] = useState({
                name: '',
                description: '',
                isPrivate: false,
                memberIds: []
            });

            const handleSubmit = (e) => {
                e.preventDefault();
                if (!formData.name.trim()) {
                    alert('Group name is required');
                    return;
                }
                onCreateGroup(formData);
                setFormData({ name: '', description: '', isPrivate: false, memberIds: [] });
            };

            const handleMemberToggle = (userId) => {
                setFormData(prev => ({
                    ...prev,
                    memberIds: prev.memberIds.includes(userId)
                        ? prev.memberIds.filter(id => id !== userId)
                        : [...prev.memberIds, userId]
                }));
            };

            if (!isOpen) return null;

            return (
                <div className="modal-overlay" onClick={onClose}>
                    <div className="modal-content" onClick={e => e.stopPropagation()}>
                        <div className="d-flex justify-content-between align-items-center mb-3">
                            <h4>Create New Group</h4>
                            <button type="button" className="btn-close" onClick={onClose}></button>
                        </div>

                        <form onSubmit={handleSubmit}>
                            <div className="mb-3">
                                <label className="form-label">Group Name</label>
                                <input
                                    type="text"
                                    className="form-control"
                                    value={formData.name}
                                    onChange={e => setFormData(prev => ({ ...prev, name: e.target.value }))}
                                    required
                                />
                            </div>

                            <div className="mb-3">
                                <label className="form-label">Description (Optional)</label>
                                <textarea
                                    className="form-control"
                                    rows="2"
                                    value={formData.description}
                                    onChange={e => setFormData(prev => ({ ...prev, description: e.target.value }))}
                                />
                            </div>

                            <div className="mb-3 form-check">
                                <input
                                    type="checkbox"
                                    className="form-check-input"
                                    checked={formData.isPrivate}
                                    onChange={e => setFormData(prev => ({ ...prev, isPrivate: e.target.checked }))}
                                />
                                <label className="form-check-label">Private Group</label>
                            </div>

                            <div className="mb-3">
                                <label className="form-label">Add Members</label>
                                <div className="group-member-list">
                                    {users.map(user => (
                                        <div key={user.id} className="group-member-item">
                                            <input
                                                type="checkbox"
                                                className="form-check-input me-2"
                                                checked={formData.memberIds.includes(user.id)}
                                                onChange={() => handleMemberToggle(user.id)}
                                            />
                                            <label className="form-check-label">
                                                {user.firstName} {user.lastName}
                                            </label>
                                        </div>
                                    ))}
                                </div>
                            </div>

                            <button type="submit" className="btn btn-primary w-100">
                                Create Group
                            </button>
                        </form>
                    </div>
                </div>
            );
        };

        const Sidebar = ({
            users,
            groups,
            currentChat,
            chatType,
            unreadCounts,
            onChatSelect,
            onNewChat,
            onNewGroup,
            currentUser,
            isMobileOpen,
            onMobileClose,
            onLogout
        }) => {
            const [searchQuery, setSearchQuery] = useState('');
            const [searchResults, setSearchResults] = useState([]);
            const [showSearchResults, setShowSearchResults] = useState(false);

            const handleSearch = async () => {
                if (!searchQuery.trim()) {
                    setShowSearchResults(false);
                    return;
                }

                try {
                    const response = await fetch(`${APIURL}/api/users/search?query=${encodeURIComponent(searchQuery)}`, {
                        headers: { 'Authorization': `Bearer ${localStorage.getItem('token')}` }
                    });
                    const results = await response.json();
                    setSearchResults(results.filter(user => user.id !== currentUser.id));
                    setShowSearchResults(true);
                } catch (error) {
                    console.error('Search error:', error);
                    setSearchResults([]);
                    setShowSearchResults(true);
                }
            };

            const handleUserSelect = (user) => {
                onChatSelect(user, 'private');
                setSearchQuery('');
                setShowSearchResults(false);
                if (window.innerWidth <= 768) {
                    onMobileClose();
                }
            };

            const handleChatSelect = (chat, type) => {
                onChatSelect(chat, type);
                if (window.innerWidth <= 768) {
                    onMobileClose();
                }
            };

            return (
                <div className={`sidebar ${isMobileOpen ? 'open' : ''}`}>
                    <div className="sidebar-header d-flex justify-content-between align-items-center">
                        <h5 className="mb-0">Telegram</h5>
                        <div>
                            <button className="btn btn-sm btn-outline-secondary me-2" onClick={onNewChat}>
                                <i className="fas fa-comment-medical"></i>
                            </button>
                            <button className="btn btn-sm btn-outline-secondary me-2" onClick={onNewGroup}>
                                <i className="fas fa-users"></i>
                            </button>
                            <button className="btn btn-sm btn-outline-danger" title="Logout" onClick={onLogout}>
                                <i className="fas fa-right-from-bracket"></i>
                            </button>
                        </div>
                    </div>

                    <div className="search-container">
                        <div className="input-group">
                            <input
                                type="text"
                                className="form-control"
                                placeholder="Search users..."
                                value={searchQuery}
                                onChange={e => setSearchQuery(e.target.value)}
                                onKeyPress={e => e.key === 'Enter' && handleSearch()}
                            />
                            <button className="btn btn-outline-secondary" onClick={handleSearch}>
                                <i className="fas fa-search"></i>
                            </button>
                        </div>

                        <SearchResults
                            results={searchResults}
                            onUserSelect={handleUserSelect}
                            isVisible={showSearchResults}
                        />
                    </div>

                    <div className="chats-list">
                        {users.filter(user => user.id !== currentUser.id).map(user => (
                            <ChatItem
                                key={`user-${user.id}`}
                                chat={user}
                                type="private"
                                isActive={currentChat?.id === user.id && chatType === 'private'}
                                unreadCount={unreadCounts[`private-${user.id}`] || 0}
                                onClick={() => handleChatSelect(user, 'private')}
                                currentUser={currentUser}
                            />
                        ))}

                        {groups.map(group => (
                            <ChatItem
                                key={`group-${group.id}`}
                                chat={group}
                                type="group"
                                isActive={currentChat?.id === group.id && chatType === 'group'}
                                unreadCount={unreadCounts[`group-${group.id}`] || 0}
                                onClick={() => handleChatSelect(group, 'group')}
                                currentUser={currentUser}
                            />
                        ))}
                    </div>
                </div>
            );
        };

        const ChatArea = ({
            currentChat,
            chatType,
            messages,
            onSendMessage,
            currentUser,
            typingUsers,
            onToggleSidebar
        }) => {
            const [messageText, setMessageText] = useState('');
            const messagesEndRef = useRef(null);

            const scrollToBottom = () => {
                messagesEndRef.current?.scrollIntoView({ behavior: 'smooth' });
            };

            useEffect(() => {
                scrollToBottom();
            }, [messages]);

            const handleSend = () => {
                if (messageText.trim() && currentChat) {
                    onSendMessage(messageText.trim());
                    setMessageText('');
                }
            };

            const handleKeyPress = (e) => {
                if (e.key === 'Enter') {
                    handleSend();
                }
            };

            if (!currentChat) {
                return (
                    <div className="chat-area">
                        <div className="mobile-header">
                            <button className="menu-toggle" onClick={onToggleSidebar}>
                                <i className="fas fa-bars"></i>
                            </button>
                            <h6 className="mb-0">Telegram Chat</h6>
                        </div>
                        <div className="chat-placeholder">
                            <div>
                                <i className="fas fa-comments fa-3x mb-3"></i>
                                <h4>Welcome to Telegram Chat</h4>
                                <p>Select a chat to start messaging</p>
                            </div>
                        </div>
                    </div>
                );
            }

            return (
                <div className="chat-area">
                    <div className="mobile-header">
                        <button className="menu-toggle" onClick={onToggleSidebar}>
                            <i className="fas fa-bars"></i>
                        </button>
                        <h6 className="mb-0">
                            {chatType === 'private'
                                ? `${currentChat.firstName} ${currentChat.lastName}`
                                : currentChat.name
                            }
                        </h6>
                    </div>

                    <div className="chat-header">
                        {chatType === 'private' ? (
                            <div className="d-flex align-items-center">
                                <StatusIndicator isOnline={currentChat.isOnline} />
                                <div className="ms-2">
                                    <h6 className="mb-0">{currentChat.firstName} {currentChat.lastName}</h6>
                                    <small className="text-muted">
                                        {currentChat.isOnline ? 'Online' : `Last seen ${formatTime(currentChat.lastSeen)}`}
                                    </small>
                                </div>
                            </div>
                        ) : (
                            <div className="d-flex align-items-center">
                                <i className="fas fa-users me-2"></i>
                                <div>
                                    <h6 className="mb-0">{currentChat.name}</h6>
                                    <small className="text-muted">{currentChat.members?.length || 0} members</small>
                                </div>
                            </div>
                        )}
                    </div>

                    <div className="chat-messages">
                        {messages.map((message, index) => (
                            <Message
                                key={message.id || index}
                                message={message}
                                currentUser={currentUser}
                            />
                        ))}

                        {typingUsers.length > 0 && (
                            <div className="typing-indicator">
                                {typingUsers.join(', ')} {typingUsers.length === 1 ? 'is' : 'are'} typing...
                            </div>
                        )}

                        <div ref={messagesEndRef} />
                    </div>

                    <div className="message-input-container">
                        <div className="input-group">
                            <button className="btn btn-outline-secondary" type="button">
                                <i className="fas fa-paperclip"></i>
                            </button>
                            <input
                                type="text"
                                className="form-control"
                                placeholder="Type a message..."
                                value={messageText}
                                onChange={e => setMessageText(e.target.value)}
                                onKeyPress={handleKeyPress}
                            />
                            <button className="btn btn-primary" onClick={handleSend}>
                                <i className="fas fa-paper-plane"></i>
                            </button>
                        </div>
                    </div>
                </div>
            );
        };

        // Main Chat Application Component
        const ChatApp = () => {
            const [currentUser, setCurrentUser] = useState(null);
            const [token, setToken] = useState(localStorage.getItem('token'));
            const [users, setUsers] = useState([]);
            const [groups, setGroups] = useState([]);
            const [currentChat, setCurrentChat] = useState(null);
            const [chatType, setChatType] = useState(null);
            const [messages, setMessages] = useState([]);
            const [unreadCounts, setUnreadCounts] = useState({});
            const [typingUsers, setTypingUsers] = useState([]);
            const [showCreateGroupModal, setShowCreateGroupModal] = useState(false);
            const [isMobileSidebarOpen, setIsMobileSidebarOpen] = useState(false);

            const { connection, isConnected } = useSignalR(token, currentUser);
            const typingTimeoutRef = useRef(null);

            // Initialize app and check for existing session
            useEffect(() => {
                if (token && !currentUser) {
                    fetch(`${APIURL}/api/auth/me`, {
                        headers: { 'Authorization': `Bearer ${token}` }
                    })
                        .then(response => {
                            if (response.ok) {
                                return response.json();
                            } else {
                                throw new Error('Invalid token');
                            }
                        })
                        .then(user => {
                            setCurrentUser(user);
                            loadChats();
                        })
                        .catch(error => {
                            console.error('Authentication error:', error);
                            localStorage.removeItem('token');
                            setToken(null);
                        });
                }
            }, [token, currentUser]);

            // Set up SignalR event listeners
            useEffect(() => {
                if (!connection || !isConnected) return;

                const handleReceivePrivateMessage = (message) => {
                    if (currentChat && chatType === 'private' && currentChat.id === message.senderId) {
                        setMessages(prev => [...prev, message]);
                        // Mark as read
                        connection.invoke("MarkMessageAsRead", message.id);
                    } else {
                        updateUnreadCount(message.senderId, 'private');
                    }
                };

                const handleReceiveGroupMessage = (message) => {
                    if (currentChat && chatType === 'group' && currentChat.id === message.groupId) {
                        setMessages(prev => [...prev, message]);
                        // Mark as read if not from current user
                        if (message.senderId !== currentUser.id) {
                            connection.invoke("MarkMessageAsRead", message.id);
                        }
                    } else {
                        updateUnreadCount(message.groupId, 'group');
                    }
                };

                const handleMessageSent = (message) => {
                    if ((chatType === 'private' && currentChat?.id === message.receiverId) ||
                        (chatType === 'group' && currentChat?.id === message.groupId)) {
                        setMessages(prev => [...prev, message]);
                    }
                };

                const handleUserStatusChanged = (userId, isOnline) => {
                    setUsers(prev => prev.map(user =>
                        user.id === userId ? { ...user, isOnline, lastSeen: new Date() } : user
                    ));
                };

                const handleUserTyping = (userId, userName, isTyping) => {
                    if (currentChat && chatType === 'private' && currentChat.id === userId) {
                        setTypingUsers(prev =>
                            isTyping
                                ? prev.includes(userName) ? prev : [...prev, userName]
                                : prev.filter(name => name !== userName)
                        );
                    }
                };

                const handleUserTypingInGroup = (groupId, userId, userName, isTyping) => {
                    if (currentChat && chatType === 'group' && currentChat.id === groupId && userId !== currentUser.id) {
                        setTypingUsers(prev =>
                            isTyping
                                ? prev.includes(userName) ? prev : [...prev, userName]
                                : prev.filter(name => name !== userName)
                        );
                    }
                };

                const handleError = (message) => {
                    console.error('SignalR Error:', message);
                    alert(`Error: ${message}`);
                };

                // Register event handlers
                connection.on("ReceivePrivateMessage", handleReceivePrivateMessage);
                connection.on("ReceiveGroupMessage", handleReceiveGroupMessage);
                connection.on("MessageSent", handleMessageSent);
                connection.on("UserStatusChanged", handleUserStatusChanged);
                connection.on("UserTyping", handleUserTyping);
                connection.on("UserTypingInGroup", handleUserTypingInGroup);
                connection.on("Error", handleError);

                // Cleanup
                return () => {
                    connection.off("ReceivePrivateMessage");
                    connection.off("ReceiveGroupMessage");
                    connection.off("MessageSent");
                    connection.off("UserStatusChanged");
                    connection.off("UserTyping");
                    connection.off("UserTypingInGroup");
                    connection.off("Error");
                };
            }, [connection, isConnected, currentChat, chatType, currentUser]);

            const loadChats = async () => {
                try {
                    // Load users
                    const usersResponse = await fetch(`${APIURL}/api/users/online`, {
                        headers: { 'Authorization': `Bearer ${token}` }
                    });
                    const usersData = await usersResponse.json();
                    setUsers(usersData);

                    // Load groups
                    const groupsResponse = await fetch(`${APIURL}/api/groups`, {
                        headers: { 'Authorization': `Bearer ${token}` }
                    });
                    const groupsData = await groupsResponse.json();
                    setGroups(groupsData);
                } catch (error) {
                    console.error('Error loading chats:', error);
                }
            };

            const loadMessages = async (chat, type) => {
                try {
                    const endpoint = type === 'private'
                        ? `/api/messages/private/${chat.id}`
                        : `/api/messages/group/${chat.id}`;

                    const response = await fetch(`${APIURL}${endpoint}`, {
                        headers: { 'Authorization': `Bearer ${token}` }
                    });
                    const messagesData = await response.json();
                    setMessages(messagesData);

                    // Clear unread count for this chat
                    const chatKey = `${type}-${chat.id}`;
                    setUnreadCounts(prev => ({ ...prev, [chatKey]: 0 }));
                } catch (error) {
                    console.error('Error loading messages:', error);
                    setMessages([]);
                }
            };

            const updateUnreadCount = (id, type) => {
                const chatKey = `${type}-${id}`;
                setUnreadCounts(prev => ({
                    ...prev,
                    [chatKey]: (prev[chatKey] || 0) + 1
                }));
            };

            const handleLogin = (user, userToken) => {
                setCurrentUser(user);
                setToken(userToken);
                loadChats();
            };

            const handleChatSelect = (chat, type) => {
                setCurrentChat(chat);
                setChatType(type);
                setTypingUsers([]);
                loadMessages(chat, type);
            };

            const handleSendMessage = (content) => {
                if (!connection || !currentChat) return;

                try {
                    if (chatType === 'private') {
                        connection.invoke("SendPrivateMessage", currentChat.id, content, 0, null);
                    } else {
                        connection.invoke("SendGroupMessage", currentChat.id, content, 0, null);
                    }
                } catch (error) {
                    console.error('Error sending message:', error);
                }
            };

            const handleCreateGroup = async (groupData) => {
                try {
                    const response = await fetch(`${APIURL}/api/groups`, {
                        method: 'POST',
                        headers: {
                            'Content-Type': 'application/json',
                            'Authorization': `Bearer ${token}`
                        },
                        body: JSON.stringify(groupData)
                    });

                    const newGroup = await response.json();
                    setGroups(prev => [...prev, newGroup]);
                    setShowCreateGroupModal(false);
                    handleChatSelect(newGroup, 'group');
                } catch (error) {
                    console.error('Error creating group:', error);
                    alert('Failed to create group');
                }
            };

            const handleMessageInput = useCallback((e) => {
                if (!currentChat || !connection) return;

                // Clear existing timeout
                if (typingTimeoutRef.current) {
                    clearTimeout(typingTimeoutRef.current);
                }

                // Send typing started
                if (chatType === 'private') {
                    connection.invoke("StartTyping", currentChat.id);
                } else {
                    connection.invoke("StartTyping", null, currentChat.id);
                }

                // Set timeout to stop typing
                typingTimeoutRef.current = setTimeout(() => {
                    if (chatType === 'private') {
                        connection.invoke("StopTyping", currentChat.id);
                    } else {
                        connection.invoke("StopTyping", null, currentChat.id);
                    }
                }, 1000);
            }, [connection, currentChat, chatType]);

            const toggleMobileSidebar = () => {
                setIsMobileSidebarOpen(!isMobileSidebarOpen);
            };

            const closeMobileSidebar = () => {
                setIsMobileSidebarOpen(false);
            };

            const handleLogout = async () => {
                try {
                    localStorage.removeItem('token');
                    if (connection) {
                        try { await connection.stop(); } catch (_) {}
                    }
                } finally {
                    setToken(null);
                    setCurrentUser(null);
                    setCurrentChat(null);
                    setChatType(null);
                    setMessages([]);
                    setUnreadCounts({});
                    setTypingUsers([]);
                    setIsMobileSidebarOpen(false);
                }
            };

            if (!currentUser) {
                return (
                    <div className="chat-app">
                        <LoginForm onLogin={handleLogin} />
                    </div>
                );
            }

            return (
                <div className="chat-app">
                    <div className="chat-container">
                        <Sidebar
                            users={users}
                            groups={groups}
                            currentChat={currentChat}
                            chatType={chatType}
                            unreadCounts={unreadCounts}
                            onChatSelect={handleChatSelect}
                            onNewChat={() => setShowCreateGroupModal(false)}
                            onNewGroup={() => setShowCreateGroupModal(true)}
                            currentUser={currentUser}
                            isMobileOpen={isMobileSidebarOpen}
                            onMobileClose={closeMobileSidebar}
                            onLogout={handleLogout}
                        />

                        <ChatArea
                            currentChat={currentChat}
                            chatType={chatType}
                            messages={messages}
                            onSendMessage={handleSendMessage}
                            currentUser={currentUser}
                            typingUsers={typingUsers}
                            onToggleSidebar={toggleMobileSidebar}
                        />
                    </div>

                    <CreateGroupModal
                        isOpen={showCreateGroupModal}
                        onClose={() => setShowCreateGroupModal(false)}
                        onCreateGroup={handleCreateGroup}
                        users={users.filter(user => user.id !== currentUser.id)}
                    />
                </div>
            );
        };

        // Render the app
        ReactDOM.render(<ChatApp />, document.getElementById('root'));